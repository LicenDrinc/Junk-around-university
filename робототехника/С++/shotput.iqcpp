{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ntouchled TouchLED2 = touchled(PORT2);\ntouchled TouchLED8 = touchled(PORT8);\nmotor LeftDriveSmart = motor(PORT1, 1, false);\nmotor RightDriveSmart = motor(PORT6, 1, true);\ngyro DrivetrainGyro = gyro(PORT7, true);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, DrivetrainGyro, 200);\n\nmotor Motor4 = motor(PORT4, true);\nmotor Motor5 = motor(PORT5, false);\ncontroller Controller = controller();\n\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Gyro\");\n  DrivetrainGyro.calibrate();\n  while (DrivetrainGyro.isCalibrating()) {\n    wait(25, msec);\n  }\n\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n#include \"iq_cpp.h\"// Allows for easier use of the VEX Library\nusing namespace vex;\n\nvoid GyroPidold(double speed=30, double head=180.0,double p=0.5,double i=0,double d=0, double distance=0.0) {\n  double curhead=0.0, prop=0.0, integral=0.0, diff=0.0, errold=0.0;\n  DrivetrainGyro.setTurnType(left);\n  LeftDriveSmart.setRotation(0,degrees);\n  RightDriveSmart.setRotation(0,degrees);\n  while((LeftDriveSmart.rotation(degrees)+RightDriveSmart.rotation(degrees))/2<distance){\n    curhead=DrivetrainGyro.heading();\n    prop = (curhead-head)*p;\n    integral = integral + (curhead-head)*i;\n    diff=(curhead-head-errold)*d;\n    errold = curhead-head;\n    LeftDriveSmart.spin(forward,speed+(prop+integral+diff),percent);\n    RightDriveSmart.spin(forward,speed-(prop+integral+diff),percent);\n  }\n  Drivetrain.stop();\n}\n\n\nvoid GyroPid(double speed=30, double head=180.0,double p=0.5,double i=0,double d=0, double distance=0.0) {\n  double curhead=0.0, prop=0.0, integral=0.0, diff=0.0, errold=0.0;\n  DrivetrainGyro.setTurnType(left);\n  LeftDriveSmart.setRotation(0,degrees);\n  RightDriveSmart.setRotation(0,degrees);\n  while( fabs(LeftDriveSmart.rotation(degrees)+RightDriveSmart.rotation(degrees)/2)< fabs(distance)){\n    curhead=DrivetrainGyro.heading();\n    prop = (curhead-head)*p;\n    integral = integral + (curhead-head)*i;\n    diff=(curhead-head-errold)*d;\n    errold = curhead-head;\n    if (distance<0){\n    LeftDriveSmart.spin(reverse,speed-(prop+integral+diff),percent);\n    RightDriveSmart.spin(reverse,speed+(prop+integral+diff),percent);\n    } else{\n    LeftDriveSmart.spin(forward,speed+(prop+integral+diff),percent);\n    RightDriveSmart.spin(forward,speed-(prop+integral+diff),percent);\n    }\n  }\n  Drivetrain.stop();\n}\n\n#define M_PI 3.14159265358979323846\nint sector=1, ab=0, af=0, i=1;\ndouble bc=0.0, ac=0.0, ad=0.0, cd=0.0, cab=0.0, gda=0.0, bd=450.0, I=0.01;\n\nvoid MM(){\n  if (sector==1) {\n    af=af+1;\n  }else if (sector==2) {\n    af=af+10;\n  }else if (sector==3) {\n    af=af+100;\n  }else if (sector==4) {\n    af=af+1000;\n  }\n  if (af>1200) {\n    af=0;\n  }\n  Brain.Screen.clearLine(4);\n  Brain.Screen.printAt(4,1,\"vod %d, %.2f\",af,cab);\n}\n\nvoid MMMM(){\n  if (sector==1) {\n    cab=cab+0.01;\n  }else if (sector==2) {\n    cab=cab+0.1;\n  }else if (sector==3) {\n    cab=cab+1;\n  }else if (sector==4) {\n    cab=cab+10;\n  }\n  if (cab>29) {\n    cab=0;\n  }\n  Brain.Screen.clearLine(4);\n  Brain.Screen.printAt(4,1,\"vod %d, %.2f\",af,cab);\n}\n\nvoid MMM(){\n  if (sector==1) {\n    cab=cab-0.01;\n  }else if (sector==2) {\n    cab=cab-0.1;\n  }else if (sector==3) {\n    cab=cab-1;\n  }else if (sector==4) {\n    cab=cab-10;\n  }\n  if (cab<(-29)) {\n    cab=0;\n  }\n  Brain.Screen.clearLine(4);\n  Brain.Screen.printAt(4,1,\"vod %d, %.2f\",af,cab);\n}\n\nvoid SECTOR(){\n  sector=sector+1;\n  I=I*10;\n  i=i*10;\n  if (sector>=5){\n    sector=1;\n  }\n  if (I>=100) {\n    I=0.01;\n  }\n  if (i>=10000) {\n    i=1;\n  }\n  Brain.Screen.clearLine(5);\n  Brain.Screen.printAt(5,1,\"%d, %.2f\",i,I);\n}\n\nint main() {\n  // Begin project code\n  //   DrivetrainGyro.calibrate(calSlow);\n  //   DrivetrainGyro.setHeading(180.0,degrees);\n  //   GyroPid(100,180,2,0.005,5,5500);\n  Controller.ButtonEDown.pressed(SECTOR);\n  Controller.ButtonEUp.pressed(MM);\n  Controller.ButtonFUp.pressed(MMMM);\n  Controller.ButtonFDown.pressed(MMM);\n  TouchLED2.on(green);\n  while (!TouchLED2.pressing()) {\n  wait(1, msec); \n  }\n  TouchLED2.on(colorType::none);\n  //af cb - dano\n  ab=af+125;\n  ac=ab*cos(cab*M_PI/180.0);\n  bc=ab*sin(cab*M_PI/180.0);\n  cd=bd-bc;\n  gda=atan(cd/ac)*180.0/M_PI;\n  ad=sqrt(cd*cd+ac*ac);\n  Brain.Screen.clearScreen();\n  Brain.Screen.printAt(1,1,\"bc=%6.2f ac=%6.2f\",bc,ac);\n  Brain.Screen.printAt(2,1,\"ab=%6.2f cab=%6.2f\",ab,cab);\n  Brain.Screen.printAt(3,1,\"ad=%6.2f gda=%6.2f\",ad,gda);\n  Drivetrain.setDriveVelocity(100, percent);\n  Drivetrain.turnFor(left, 90, degrees);\n  Drivetrain.driveFor(reverse,150,mm);\n  wait(200,msec);\n  Drivetrain.driveFor(forward,60,mm);//horizont\n  Drivetrain.turnFor(right, 90, degrees);\n  Drivetrain.driveFor(reverse,150,mm);\n  wait(200,msec);\n  Drivetrain.driveFor(forward,85,mm);//vertical\n  \n  Motor4.setStopping(hold);\n  Motor4.setTimeout(1, seconds);\n  Motor4.spinFor(reverse,150,degrees);\n  Motor4.setPosition(0,degrees);\n  Motor4.spinFor(forward,85,degrees);\n  Motor4.setTimeout(3,seconds);\n\n  Motor5.setStopping(hold);\n  Motor5.setTimeout(1,seconds);\n  Motor5.spinFor(forward,150,degrees);\n  Motor5.setPosition(0,degrees);\n  Motor5.spinFor(reverse,150,degrees);\n  Motor5.setPosition(0,degrees);\n  TouchLED2.setBlink(222,0.1,0.1);\n  DrivetrainGyro.calibrate(calNormal);\n  TouchLED2.setBlink(100,0,0);\n  Drivetrain.setHeading(180,degrees);\n  double targethead=180+gda;\n  Drivetrain.turnToHeading(targethead,degrees);\n  GyroPidold(40,targethead,1,0.00005,5, (ad-190)/200*360);\n  Motor5.setStopping(hold);\n  Motor5.setTimeout(1,seconds);\n  Motor5.spinFor(forward,150,degrees);\n  Motor4.setStopping(hold);\n  Motor4.setTimeout(5,seconds);\n  Motor4.spinFor(forward,500,degrees);\n  GyroPid(40,targethead,1,0.00005,5, -(ad+190)/200*360);\n  Drivetrain.turnToHeading(90+targethead-gda,degrees);\n  Drivetrain.setDriveVelocity(50,percent);\n  Drivetrain.driveFor(forward,300,mm);\n  wait(100,msec);\n  Motor4.setStopping(hold);\n  Motor4.setTimeout(5,seconds);\n  Motor4.spinFor(forward,-500,degrees);\n  Motor5.setStopping(hold);\n  Motor5.setTimeout(1,seconds);\n  Motor5.spinFor(forward,-150,degrees);\n  Drivetrain.driveFor(reverse,350,mm);\n}","textLanguage":"cpp","rconfig":[{"port":[2],"name":"TouchLED2","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[8],"name":"TouchLED8","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[1,6,7],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"smart","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[4],"name":"Motor4","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"вперёд","rev":"обратно"},"triportSourcePort":22},{"port":[5],"name":"Motor5","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"вперёд","rev":"обратно"},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20210916.19.00.00","appVersion":"2.2.2","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}